#!/usr/bin/env python

import argparse
import sys
import gzip
import json
import pysam
from collections import defaultdict
from statistics import mean, median
from bisect import bisect

app_desc = "Aggregate depth information individual depth files generated by SAMtools mpileup."
argparser = argparse.ArgumentParser(description=app_desc)

in_help = """ Input file which lists paths to depth files.
    One depth file per sample. One file per line. """
argparser.add_argument('-i', '--in', metavar='file', dest='in_files_list', required=True,
                       help=in_help)

out_help = """ Output file of depth information compressed with bgzip.
    In addition to this file, the tabix index will be produced. """
argparser.add_argument('-o', '--out', metavar='file', dest='out_file_name', required=True,
                       help=out_help)

expected_chr_help = """ Expected sole chromosome identifier.  Will be inferred if not supplied. """
argparser.add_argument('-c', '--chr', metavar='string', dest='chromosome', required=False,
                       help=expected_chr_help)

DEPTH_BREAKS = [1, 5, 10, 15, 20, 25, 30, 50, 100]


def count_depths(depths):
    counts = [0] * len(DEPTH_BREAKS)
    for depth in depths:
        for idx, break_val in enumerate(DEPTH_BREAKS):
            if depth >= break_val:
                counts[idx] += 1
    return(counts)


def read_chr_from_file(in_path):
    with gzip.open(input_paths[0], 'rt') as first_file:
        line = first_file.readline()
        if line:
            chrom, pos, dp = line.rstrip().split()
        else:
            print("First input file empty", file=sys.stderr)
            sys.exit(1)
    return(chrom)


# Generator to read n_lines at a time from each file.
# Return list of lists of lines from each file:
#  [[file_1_lines],[file_2_lines],[...]]
def pileup_reader(input_paths, n_lines=1):
    open_files = []

    # Open all the files and create itterators
    for in_path in input_paths:
        open_files.append(gzip.open(in_path, 'rt'))

    try:
        content_lists = []
        file_lines = []
        while open_files:
            del content_lists[:]
            for i, file in enumerate(open_files):
                del file_lines[:]
                for x in range(n_lines):
                    file_lines.append(file.readline())
                content_lists.append(file_lines)

                # Close and mark file for removal once exhausted
                if file_lines[-1] == '':
                    file.close()
                    open_files[i] = None

            # Remove exausted files from open files list
            open_files = list(filter(lambda x: x is not None, open_files))
            yield(content_lists)
    finally:
        for file in open_files:
            file.close()


def main(input_paths, chromosome, output_path):
    # Create non-chr prefixed chromosome identifier
    chromosome_id = chromosome.replace('chr', '', 1)
    n_indv = len(input_paths)

    # Live dangerously with output file
    ofile = pysam.BGZFile(output_path, 'w')

    # Collect depths in batches of n_lines from each file at a time.
    agg_depths = defaultdict(list)
    max_positions = []
    # Each member of content_lists is a list of lines from an input file
    for content_lists in pileup_reader(input_paths, n_lines=1000000):
        # Process file contents individually
        for file_contents in content_lists:
            for line in file_contents:
                if line:
                    chrom, pos, dp = line.rstrip().split()
                    if chrom != chromosome:
                        raise Exception("""Multiple chromosomes detected in input.
                                        Only one is allowed.""")
                    agg_depths[int(pos)].append(int(dp))

            # Handle batch ending precisely at end of file. Remaining readline calls are all empty.
            if agg_depths:
                max_positions.append(max(agg_depths.keys()))

        # Greatest common position of files read
        if max_positions:
            gr_comm_pos = min(max_positions)
        else:
            gr_comm_pos = 0

        # Get bisection index of greatest common position
        asc_keys = sorted(agg_depths)
        b_idx = bisect(asc_keys, gr_comm_pos)

        # Process aggregated depth counts up to greatest common position, asc_keys[b_idex]
        #  Remove depth counts from agg_deptsh as they are summarized.
        for pkey in asc_keys[:b_idx]:
            depths = agg_depths.pop(pkey)
            depth_counts = count_depths(depths)

            summary = {}
            summary["chrom"] = chromosome_id
            summary["start"] = pkey
            summary["end"] = pkey
            summary["mean"] = mean(depths)
            summary["median"] = median(depths)

            # Calculate proportion of individuals counted in each bin for current position
            for br, depth_count in zip(DEPTH_BREAKS, depth_counts):
                proportion = depth_count / n_indv
                summary[br] = proportion

            agg_row = f"{chromosome_id}\t{pkey}\t{pkey}\t{json.dumps(summary)}\n"
            ofile.write(agg_row.encode())

        # Start with max position of remaining agg depths (if any) for next batch.
        if agg_depths:
            max_positions = [max(agg_depths.keys())]
        else:
            max_positions = []

    # Done with batch processing.
    ofile.close()

    print(f"Done processing {n_indv} files.")


if __name__ == '__main__':
    args = argparser.parse_args()

    # Process list of depth file paths
    input_paths = []
    with open(args.in_files_list, 'r') as ifile:
        for line in ifile:
            line = line.strip()
            if line:
                input_paths.append(line)

    # If input paths is empty, we're done
    if not input_paths:
        print("Input paths empty", file=sys.stderr)
        sys.exit()

    # Get chromosome value from args or first file for chekcing data is all from same chromosome.
    if args.chromosome:
        chromosome = args.chromosome
    else:
        chromosome = read_chr_from_file(input_paths[0])

    main(input_paths, chromosome, args.out_file_name)
